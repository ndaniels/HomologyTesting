#!/usr/bin/env python
#
# generate-hmm.py - generate HMM files from multiple alignment files
# Copyright 2010 Jeffrey Finkelstein
#
# This file is part of smurf.
#
# smurf is free software: you can redistribute it and/or modify it under the
# terms of the GNU General Public License as published by the Free Software
# Foundation, either version 2 of the License, or (at your option) any later
# version.
#
# smurf is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with
# smurf.  If not, see <http://www.gnu.org/licenses/>.

import os
import os.path
import subprocess
import sys


from gargamel.argumentparsers import MrfArgumentParser
from gargamel.constants import MRFBUILD_EXECUTABLE
from gargamel.constants import SSANNOTATE_EXECUTABLE
from gargamel.constants import MRF_FILENAME
from gargamel.constants import MRFY
from gargamel.constants import MRFBUILD_OPTIONS
from gargamel.constants import HMM_SUFFIX
from gargamel.constants import HMM_PREFIX
from gargamel.constants import HMMER
from gargamel.constants import HMMER_HMM_FILENAME
from gargamel.constants import HMMER_HMMBUILD_EXECUTABLE
from gargamel.constants import MATT_PREFIX
from gargamel.constants import SMURF
from gargamel.constants import SMURF_HMM_FILENAME
from gargamel.constants import SMURF_HMMBUILD_EXECUTABLE
from gargamel.constants import SMURF_PREPARSE_EXECUTABLE
from gargamel.constants import PROFILE_SMURF
from gargamel.constants import PROFILE_SMURF_HMM_FILENAME
from gargamel.constants import PROFILE_SMURF_HMMBUILD_EXECUTABLE
from gargamel.constants import PROFILE_SMURF_PREPARSE_EXECUTABLE
from gargamel.constants import SMURF_LITE
from gargamel.constants import SMURF_LITE_HMM_FILENAME
from gargamel.constants import SMURF_LITE_HMMBUILD_EXECUTABLE
from gargamel.constants import SMURF_LITE_PREPARSE_EXECUTABLE
from gargamel.constants import HMMER_HMMBUILD_OPTIONS
from gargamel.constants import SMURF_HMMBUILD_OPTIONS
from gargamel.constants import PROFILE_SMURF_HMMBUILD_OPTIONS
from gargamel.constants import SMURF_LITE_HMMBUILD_OPTIONS
from gargamel.logger import logger

# a brief description of the purpose of this program
PROGRAM_DESCRIPTION = 'Generates HMM files from multiple alignment files ' + \
                      '(generated by the generate-matt-alignments.py script)'

# create a parser for command-line arguments, with a description of the purpose
# of this program
argparser = MrfArgumentParser(PROGRAM_DESCRIPTION)

# parse the command-line arguments
parsed_args = argparser.parse_args()

# get the values from the command-line arguments
output_dir = parsed_args.outputdir.rstrip('/')  # remove trailing slash
aligner = parsed_args.aligner

simev_frequency = parsed_args.simev_frequency
simev_count = parsed_args.simev_count
simev_threshold = parsed_args.simev_threshold

# determine the amount of logging info to output
if parsed_args.verbose:
    from logging import DEBUG
    from gargamel.logger import console_handler
    console_handler.setLevel(DEBUG)

# summary of the program configuration
config = {'output_dir' : output_dir, 'aligner' : aligner}
logger.debug('Program configuration: ' + str(config))

# end the program if the output dir doesn't exist
logger.debug('Checking whether output directory exists...')
if not os.path.isdir(output_dir):
    logger.critical('Output directory ' + output_dir + ' does not yet exist')
    logger.critical('Please run generate-matt-alignments.py first')
    sys.exit(2)

logger.debug('Determining which hierarchy levels were left out during '
             'training...')
logger.debug('  output_dir contains: ' + str(os.listdir(output_dir)))
sunids = filter(lambda x: os.path.isdir(os.path.join(output_dir, x)),
                os.listdir(output_dir))
logger.debug('  sunids: ' + str(sunids))

for sunid in sunids:

    level_output_dir = os.path.join(output_dir, sunid)
    aligner_output_dir = os.path.join(level_output_dir, aligner)

    # create the output for the aligner if it doesn't already exist
    if os.path.isdir(aligner_output_dir):
        logger.warning('directory ' + aligner_output_dir + ' already exists')
    else:
        os.mkdir(aligner_output_dir)

    # determine which executable and multiple alignment file to use for the
    # hmmbuild step, and determine the name of the HMM file
    if aligner == MRFY:
        executable = MRFBUILD_EXECUTABLE
        if float(simev_frequency) > 0.0:
          preparse_executable = SIMEV_MRFY_SSANOTATE_EXECUTABLE
        else:
          preparse_executable = SSANNOTATE_EXECUTABLE
        hmm_filename = MRF_FILENAME
        hmmbuild_options = MRFBUILD_OPTIONS
    elif aligner == HMMER:
        executable = HMMER_HMMBUILD_EXECUTABLE
        hmm_filename = HMMER_HMM_FILENAME
        hmmbuild_options = HMMER_HMMBUILD_OPTIONS
    elif aligner == PROFILE_SMURF:
        executable = PROFILE_SMURF_HMMBUILD_EXECUTABLE
        preparse_executable = PROFILE_SMURF_PREPARSE_EXECUTABLE
        hmm_filename = PROFILE_SMURF_HMM_FILENAME
        hmmbuild_options = PROFILE_SMURF_HMMBUILD_OPTIONS
    elif aligner == SMURF_LITE:
        executable = SMURF_LITE_HMMBUILD_EXECUTABLE
        preparse_executable = SMURF_LITE_PREPARSE_EXECUTABLE
        hmm_filename = SMURF_LITE_HMM_FILENAME
        hmmbuild_options = SMURF_LITE_HMMBUILD_OPTIONS
    else:
        logger.critical('Unknown aligner type: ' + aligner)
        sys.exit(1)

    mult_alignment_file = os.path.join(level_output_dir,
                                       MATT_PREFIX + '.ssi')
                                       
    if not os.path.isfile(mult_alignment_file):
      logger.debug('Group not aligned; could not find alignment file ' + mult_alignment_file + ' - skipping.')
      continue                                   
    
    # call smurf-preparse to set up beta strand goodness
    logger.debug('Running SSAnnotate...')
    mult_alignment_file = os.path.join(level_output_dir,
                                       MATT_PREFIX + '_' + aligner + '.ssi')
    if float(simev_frequency) > 0.0:        
      preparse_cmd = [preparse_executable,
                      os.path.join(level_output_dir, MATT_PREFIX + '.pdb'),
                      os.path.join(level_output_dir, MATT_PREFIX + '.fasta'),
                      mult_alignment_file,
                      simev_frequency,
                      simev_count,
                      simev_threshold,
                      'false' # do NOT run blast augmentation.
                      ]
    else:
      preparse_cmd = [preparse_executable,
                      os.path.join(level_output_dir, MATT_PREFIX),
                      ]
    logger.debug('  ' + ' '.join(preparse_cmd))
    return_code = subprocess.call(preparse_cmd)
    logger.debug('Return code: ' + str(return_code))
      
    # generate a hidden Markov model from the multiple alignment generated by
    # matt (specifically, the .ssi file)
    
    logger.debug('Running mrfbuild...')
    mrfbuild_cmd = filter(lambda x: len(x)>0, [executable,
                    hmmbuild_options,
                    os.path.join(aligner_output_dir, hmm_filename),
                    mult_alignment_file])
    logger.debug('  ' + ' '.join(mrfbuild_cmd))
      
    return_code = subprocess.call(' '.join(mrfbuild_cmd), shell=True)
    logger.debug('Return code: ' + str(return_code))
